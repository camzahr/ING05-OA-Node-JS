{
  "name": "pagelet",
  "version": "0.9.3",
  "description": "pagelet",
  "main": "index.js",
  "scripts": {
    "100%": "istanbul check-coverage --statements 100 --functions 100 --lines 100 --branches 100",
    "test": "mocha $(find test -name '*.test.js')",
    "watch": "mocha --watch $(find test -name '*.test.js')",
    "coverage": "istanbul cover ./node_modules/.bin/_mocha -- $(find test -name '*.test.js')",
    "test-travis": "istanbul cover node_modules/.bin/_mocha --report lcovonly -- $(find test -name '*.test.js')"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/bigpipe/pagelet.git"
  },
  "keywords": [
    "pagelet",
    "bigpipe"
  ],
  "author": {
    "name": "Arnout Kazemier"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/bigpipe/pagelet/issues"
  },
  "homepage": "http://bigpipe.io",
  "dependencies": {
    "async": "0.9.x",
    "demolish": "1.0.x",
    "diagnostics": "0.0.x",
    "dot-component": "0.1.x",
    "eventemitter3": "0.1.x",
    "fabricator": "0.5.x",
    "formidable": "1.0.x",
    "fusing": "1.0.x",
    "routable": "0.0.x",
    "temper": "0.3.x"
  },
  "devDependencies": {
    "assume": "1.1.x",
    "bigpipe": "github:bigpipe/bigpipe",
    "istanbul": "0.3.x",
    "mocha": "2.2.x",
    "pre-commit": "1.0.x",
    "react": "0.13.x",
    "react-jsx": "0.13.x"
  },
  "gitHead": "0f39dfddfbeeec556cbd5cff1c2945a6bb334532",
  "readme": "# Pagelet\n\n[![Version npm][version]](http://browsenpm.org/package/pagelet)[![Build Status][build]](https://travis-ci.org/bigpipe/pagelet)[![Dependencies][david]](https://david-dm.org/bigpipe/pagelet)[![Coverage Status][cover]](https://coveralls.io/r/bigpipe/pagelet?branch=master)\n\n[version]: http://img.shields.io/npm/v/pagelet.svg?style=flat-square\n[build]: http://img.shields.io/travis/bigpipe/pagelet/master.svg?style=flat-square\n[david]: https://img.shields.io/david/bigpipe/pagelet.svg?style=flat-square\n[cover]: http://img.shields.io/coveralls/bigpipe/pagelet/master.svg?style=flat-square\n\n## Installation\n\nThere are two different ways of using Pagelet in your project. If you're already\nusing the [BigPipe] framework you don't need to install anything as this module\nis exposed using:\n\n```js\nvar Pagelet = require('bigpipe').Pagelet;\n```\n\nIf you want to build stand-alone pagelets to be used in BigPipe or just want to\nuse the Pagelet pattern in your application you need to install the module your\nself using:\n\n```\nnpm install --save pagelet\n```\n\nAnd require it in your application as:\n\n```js\nvar Pagelet = require('pagelet');\n```\n\nWhich is also the code as we assume in all the examples in our documentation.\n\n## Table of Contents\n\n**Pagelet function**\n- [Pagelet.extend](#pageletextend)\n- [Pagelet.on](#pageleton)\n- [Pagelet.traverse](#pagelettraverse)\n\n**Pagelet instance**\n- [Pagelet.name](#pageletname)\n- [Pagelet.streaming](#pageletstreaming)\n- [Pagelet.RPC](#pageletrpc)\n- [Pagelet.mode](#pageletmode)\n- [Pagelet.fragment](#pageletfragment)\n- [Pagelet.remove](#pageletremove)\n- [Pagelet.view](#pageletview)\n- [Pagelet.error](#pageleterror)\n- [Pagelet.engine](#pageletengine)\n- [Pagelet.query](#pageletquery)\n- [Pagelet.css](#pageletcss)\n- [Pagelet.js](#pageletjs)\n- [Pagelet.dependencies](#pageletdependencies)\n- [Pagelet.get()](#pageletget)\n- [Pagelet.authorize()](#pageletauthorize)\n- [Pagelet.initialize()](#pageletinitialize)\n- [Pagelet.pagelets](#pageletpagelets)\n- [Pagelet.id](#pageletid)\n- [Pagelet.substream](#pageletsubstream)\n- [Pagelet._parent](#pageletparent)\n\n### Pagelet.extend\n\nThe `.extend` method is used for creating a new Pagelet constructor. It\nsubclasses the `Pagelet` constructor just like you're used to when using\n[Backbone]. It accepts an object which will be automatically applied as part of\nthe prototype:\n\n```js\nPagelet.extend({\n  js: 'client.js',\n  css: 'sidebar.styl',\n  view: 'templ.jade',\n\n  get: function get() {\n    // do stuff when GET is called via render\n  }\n});\n```\n\n### Pagelet.on\n\nIn [BigPipe] we need to know where the Pagelet is required from so we figure out\nhow to correctly resolve the relative paths of the `css`, `js` and `view`\nproperties.\n\nSo a full constructed Pagelet instance looks like:\n\n```js\nPagelet.extend({\n  my: 'prop',\n  and: function () {}\n}).on(module);\n```\n\nThis has the added benefit of no longer needing to do `module.exports = ..` in\nyour code as the `Pagelet.on` method automatically does this for you.\n\n### Pagelet.traverse\n\nRecursively find and construct all pagelets. Uses the\n[pagelets property](#pageletpagelets) to find additional child pagelets. Usually\nthere is no need to call this manually. [BigPipe] will make sure all pagelets\nare recursively discovered. Traverse should be called with the name of the\nparent pagelet, so each child has a proper reference.\n\n```\nPagelet.extend({\n  name: 'parent name',\n  pagelets: {\n    one: require('pagelet'),\n    two: require('pagelet')\n  }\n}).traverse('parent name');\n```\n\n### Pagelet.name\n\n_required:_ **writable, string**\n\nEvery pagelet should have a name, it's one of the ways that [BigPipe] uses to\nidentify which pagelet and where it should be loaded on the page. The name\nshould be an unique but human readable string as this will be used as value for\nthe `data-pagelet=\"\"` attributes on your [Page], but this name is also when you\nwant to check if a `Pagelet` is available.\n\n```js\nPagelet.extend({\n  name: 'sidebar'\n}).on(module);\n```\n\nIf no `name` property has been set on the Pagelet it will take the `key` that\nwas used when you specified the pagelets for the [Page]:\n\n```js\nvar Page = require('bigpipe').Page;\n\nPage.extend({\n  pagelets: {\n    sidebar: '../yourpagelet.js',\n    another: require('../yourpagelet.js')\n  }\n}).on(module);\n```\n\nIf you supplied the [Page] instance if a path to a folder of pagelet folders it\nwill use the name of the folders:\n\n```js\nvar Page = require('bigpipe').Page;\n\nPage.extend({\n  pagelets: './pagelets-folder'\n}).on(module);\n```\n```\n|- page.js\n|- pagelets-folder/\n   |\n   |- foo/\n   |- bar/\n   |- baz/\n```\n\nSo in the example above you would have 3 pagelets with the names `foo`, `bar` and\n`baz`.\n\n### Pagelet.streaming\n\n_optional:_ **writable, boolean**\n\nWhen enabled we will stream the submit of each form that is within a Pagelet to\nthe server instead of using the default full page refreshes. After sending the\ndata the resulting HTML will be used to only update the contents of the pagelet.\n\nIf you want to opt-out of this with one form you can add a\n`data-pagelet-async=\"false\"` attribute to the form element.\n\n**Default value**: `false`\n\n```js\nPagelet.extend({\n  streaming: true\n});\n```\n\n### Pagelet.RPC\n\n_optional:_ **writable, array**\n\nThe `RPC` array specifies the methods that can be remotely called from the\nclient/browser. Please note that they are not actually send to the client as\nthese functions will execute on the server and transfer the result back to the\nclient.\n\nThe first argument that these functions receive is an error first style callback\nwhich is used to transfer the response back to the client. All other arguments\nwill be the arguments that were used to call the method on the client.\n\n**Default value**: `[]`\n\n ```js\nPagelet.extend({\n  RPC: [ 'methodname' ],\n\n  methodname: function methodname(reply, arg1, arg2) {\n\n  }\n}).on(module);\n```\n\n### Pagelet.mode\n\n_optional:_ **writable, string**\n\nSet the render mode the pagelet fragment. This will determine which client side\nmethod will be called to create elements. For instance, this mode can be changed\nto `svg` to generate SVG elements with the SVG namespaceURI.\n\n**Default value**: `html`\n\n```js\nPagelet.extend({\n  mode: 'svg',\n}).on(module);\n```\n\nWe currently support two different render modes:\n\n- **html**: Render HTML elements.\n- **svg**: Render SVG elements.\n\n### Pagelet.fragment\n\n_optional:_ **writable, string**\n\nA default fragment is provided via `Pagelet.fragment`, however it is\npossible to overwrite this default fragment with a custom fragment. This fragment\nis used by render to generate content with appropriate data to work with [BigPipe].\nChange `Pagelet.fragment` if you'd like to invoke render and generate custom output.\n\n**Default value**: see [pagelet.fragment][frag]\n\n```js\nPagelet.extend({\n  fragment: '<div>{pagelet:template}</div>',\n}).on(module);\n```\n\nThe received fragment can contain various of placeholders which will be replaced\nbefore the template is flushed to the browser. The following placeholders are\nsupported:\n\n- `{pagelet:template}` This contains the rendered output of your specified view.\n- `{pagelet:name}` The name of pagelet we're currently rendering.\n- `{pagelet:data}` A JSON string blob of meta data about the pagelet which contains:\n  - `id`: String, A unique id of the pagelet that was rendered.\n  - `mode`: String, the render mode that you've configured.\n  - `rpc`: Array, names of the RPC methods.\n  - `remove`: Boolean, should this be removed from the DOM.\n  - `streaming`: Boolean, should we stream form submits\n  - `parent`: String, name of the parent pagelet.\n  - `hash`: Object, containing the MD5 hashes of the client view.\n\n### Pagelet.remove\n\n_optional:_ **writable, boolean**\n\nThis instructs our render engine to remove the pagelet placeholders from the DOM\nstructure if we've got no pagelets available for it. This makes it easier to\ncreate conditional layouts without having to worry about DOM elements that are\nleft behind.\n\n**Default value**: `true`\n\n```js\nPagelet.extend({\n  if: function conditional(req, next) {\n    next(false);\n  },\n  remove: false\n}).on(module);\n```\n\n### Pagelet.view\n\n_required:_ **writable, string**\n\nThe view is a reference to the template that we render inside the\n`data-pagelet=\"<name>\"` placeholders. Please make sure that your template can be\nrendered on both the client and server side. Take a look at our [temper] project\nfor template engines that we support.\n\n### Pagelet.error\n\n_optional:_ **writable, string**\n\nJust like the `Pagelet.view` this is a reference to a template that we will\nrender in your `data-pagelet=\"<name>\"` placeholders but this template is only\nrendered when:\n\n1. We receive an `Error` argument in our callback that we supply to the\n   `Pagelet#get` method.\n2. Your `Pagelet.view` throws an error when we're rendering the template.\n\nIf this property is not set we will default to a template that ships with this\nPagelet by default. This template includes a small HTML fragment that states the\nerror.\n\n### Pagelet.engine\n\n_optional:_ **writable, string**\n\nWe attempt to detect the correct template engine based on filename as well as\nthe template engine's that we can require. It is possible that we make the wrong\nassumption and you wanted to use `handlebars` for your `.mustache` based\ntemplates but it choose to use `hogan.js` instead.\n\n```js\nPagelet.extend({\n  view: 'sidebar.mustache',\n  engine: 'handlebars'\n}).on(module);\n```\n\n**Please note that the engine needs to be compatible with the [temper] module\nthat we use to compile the templates**\n\n### Pagelet.query\n\n_optional:_ **writable, array**\n\nFor optimal performance the data that is send to the client will be minimal\nand dependant on they query that is provided. Data can be supplied to the client\nby listing the keys (nested paths in dot notation) of which the data should be\nsend to the client. In the example only the content of `mydata` and `nested.is`\nwill be send.\n\n```js\nPagelet.extend({\n  query: [ 'mydata', 'nested.is' ],\n  get: function get(done) {\n    done(null, {\n      mydata: 'test',\n      nested: { is: 'allowed', left: 'alone' },\n      more: 'data'\n    });\n  }\n}).on(module);\n```\n\n### Pagelet.css\n\n_optional:_ **writable, string**\n\nThe location of the styling for **only this** pagelet. You should assume that\nyou bundle all the CSS that is required to fully render this pagelet. By\neliminating inherited CSS it will be easier for you to re-use this pagelet on\nother pages as well as in other projects.\n\n```js\nPagelet.extend({\n  css: './my-little-pony.styl'\n}).on(module);\n```\n\n**Please note that this doesn't have to be a `.css` file as we will\ntransparently pre-process these files for you. See the [smithy] project for the\ncompatible pre-processors.**\n\n### Pagelet.js\n\n_optional:_ **writable, string**\n\nAs you might have guessed, this is the location of the JavaScript that you want\nto have loaded for your pagelet. We use [fortress] to sandbox this JavaScript in\na dedicated `iframe` so the code you write is not affected and will not affect\nother pagelets on the same page. This also makes it relatively save to extend\nthe build-in primitives of JavaScript (adding new properties to Array etc).\n\nUnlike the `view` and `css` we do not pre-process the JavaScript. But this does\nnot mean you cannot use CoffeeScript or other pre-processed languages inside a\nPagelet. It just means that you have to compile your files to a proper\nJavaScript file and point to that location instead.\n\n```js\nPagelet.extend({\n  js: './library.js'\n}).on(module);\n```\n\n**Please note that the sandboxing is not there as a security feature, it was\nonly designed to prevent code from different pagelets clashing with each other**\n\n### Pagelet.dependencies\n\n_optional:_ **writable, array**\n\nAn array of dependencies that your pagelet depends on which should be loaded in\nadvance and available on the page before any CSS or JavaScript is executed. The\nfiles listed in this array can either a be CSS or JavaScript resource.\n\n```js\npagelet.extend({\n  dependencies: [\n    'https://google.com/ga.js'\n  ]\n}).on(module);\n```\n\n### Pagelet.get()\n\n_required:_ **writable, function**\n\nGet provides the data that is used for rendering the output of the Pagelet.\n\nThe `get` method receives one argument:\n\n- done: A completion callback which accepts two arguments. This callback should be\ncalled when your custom implementation has finished gathering data from all sources.\nCalling `done(error, data)` will allow the `render` method to complete its work.\nThe data provided to the callback will be used to render the actual Pagelet.\n\n```js\nPagelet.extend({\n  get: function get(done) {\n    var data = { provide: 'data-async' };\n    done(error, data);\n  },\n}).on(module);\n```\n\n### Pagelet.if()\n\n_optional:_ **writable, function**\n\nThe `if` function allows you to build conditional pagelets. These pagelets will\nonly be rendered if the supplied callback receives `true`. This can be used to\nbuild private pagelets like administrator pagelets that require special\npermissions in order to be shown seen.\n\nWhen used in [BigPipe] we take this concept even further as it's possible to set\nan array of pagelets that could be used in the placeholder. You could use to\nshow login and logout buttons, sign up or getting starting pagelets or even\nstart doing A/B testing with multiple pagelets! The possibilities are endless\nhere.\n\nThe supplied function receives 2 or 3 arguments:\n- req: The incoming HTTP requirement.\n- left: An array of pagelets that will tried if this pagelet callback resolves\n  to false. This is an optional argument, if you do no specify it your last\n  argument will be the completion callback that is listed below.\n- done: A completion callback which only accepts one argument, a boolean. If\n  this boolean has been set to `true` the pagelet is authorized on the page and\n  will be rendered as expected. When the argument evaluates as `false` (so also\n  null, undefined, 0 etc) we assume that it's disallowed and should not be\n  rendered.\n\n```js\nPagelet.extend({\n  if: function conditional(req, done) {\n    done(true); // True indicates that the request is authorized for access.\n  }\n}).on(module);\n```\n\nOr with 3 arguments:\n\n```js\nPagelet.extend({\n  if: function abtest(req, left, done) {\n    if (!left.length) return done(true);\n    done(Math.random() < 0.5);\n  }\n}).on(module);\n```\n\n### Pagelet.initialize()\n\n_optional:_ **writable, function**\n\nThe pagelet has been initialised. If you have an authorization function this\nfunction will only be called **after** a successful authorization. If no\nauthorization hook is provided it should be called instantly.\n\n```js\nPagelet.extend({\n  initialize: function () {\n    this.once('event', function () {\n      doStuff();\n    });\n  }\n});\n```\n\n### Pagelet.pagelets\n\n_optional:_ **writable, string|array|object**\n\nEach pagelet can contain `n` child pagelets. Similar to using pagelets through\n[BigPipe], the pagelets property can be a string (filepath to file or directory),\narray or object containing multiple pagelets. All subsequent child pagelets will\nbe converged on one stack to allow full parallel initialization. The client will\nhandle deferred rendering of child pagelets, also see [_parent](#pageletparent).\n\n```\nPagelet.extend({\n  pagelets: {\n    one: require('pagelet'),\n    two: require('pagelet')\n  }\n});\n```\n\n### Pagelet.id\n\n**read only**\n\nThe unique id of a given pagelet instance. Please note that this is not a\npersistent id and will differ between every single initialised instance.\n\n### Pagelet.substream\n\n**read only**\n\nThe pagelet can also be initialised through [Primus] so it can be used for\nreal-time communication (and make things like [RPC](#pagelet-rpc) work). The\ncommunication is done over a [substream] which allows Primus multiplex the\nconnection between various of endpoints.\n\n### Pagelet._parent\n\n**read only**\n\nIf the current pagelet is intialized from another pagelet, it will have a `_parent`\nreference. The pagelets' parent name will be stored so that client-side\ninitialization is deferred till the parent is rendered.\n\n## License\n\nMIT\n\n[Backbone]: http://backbonejs.com\n[BigPipe]: http://bigpipe.io\n[Page]: http://bigpipe.io#page\n[temper]: http://github.com/bigpipe/temper\n[smithy]: http://github.com/observing/smithy\n[fortress]: http://github.com/bigpipe/fortress\n[frag]: https://github.com/bigpipe/pagelet/blob/master/pagelet.fragment\n[Primus]: https://github.com/primus/primus\n[substream]: https://github.com/primus/substream\n",
  "readmeFilename": "README.md",
  "_id": "pagelet@0.9.3",
  "_shasum": "d1bc562fd8fddedbae4123c89bb02bb65660b5ed",
  "_from": "bigpipe/pagelet",
  "_resolved": "git://github.com/bigpipe/pagelet.git#0f39dfddfbeeec556cbd5cff1c2945a6bb334532"
}
